// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.10;

import {ERC165} from "@openzeppelin/contracts/utils/introspection/ERC165.sol";
import {IGroth16Verifier} from "../../interfaces/IGroth16Verifier.sol";
import {IRequestValidator} from "../../interfaces/IRequestValidator.sol";
import {Ownable2StepUpgradeable} from "@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol";
import {Strings} from "@openzeppelin/contracts/utils/Strings.sol";
import {RequestValidatorBase} from "./RequestValidatorBase.sol";

error WrongCircuitID(string circuitID);
error InvalidQueryHash(uint256 expectedQueryHash, uint256 actualQueryHash);
error InvalidGroupID(uint256 groupID);
error TooManyQueries(uint256 operatorCount);
error InvalidGroth16Proof();

contract LinkedMultiQueryValidator is Ownable2StepUpgradeable, RequestValidatorBase, ERC165 {
    // This should be limited to the real number of queries in which operator != 0
    struct Query {
        uint256[] claimPathKey;
        uint256[] operator; // when checking SD take operator from here
        uint256[] slotIndex;
        uint256[][] value;
        uint256[] queryHash;
        string[] circuitIds;
        uint256 groupID;
        uint256 verifierID;
    }

    // keccak256(abi.encodePacked("groupID"))
    bytes32 private constant GROUPID_NAME =
        0xdab5ca4f3738dce0cd25851a4aa9160ebdfb1678ef20ca14c9a3e9217058455a;
    // keccak256(abi.encodePacked("verifierID"))
    bytes32 private constant VERIFIERID_NAME =
        0xa6ade9d39b76f319076fc4ad150ee37167dd21433b39e1d533a5d6b635762abe;
    // keccak256(abi.encodePacked("nullifierSessionID"))
    bytes32 private constant NULLIFIERSESSIONID_NAME =
        0x24cea8e4716dcdf091e4abcbd3ea617d9a5dd308b90afb5da0d75e56b3c0bc95;

    struct PubSignals {
        uint256 linkID;
        uint256 merklized;
        uint256[10] operatorOutput;
        uint256[10] circuitQueryHash;
    }

    string public constant VERSION = "1.0.0-beta.1";
    string internal constant CIRCUIT_ID = "linkedMultiQuery10-beta.1";
    uint256 internal constant QUERIES_COUNT = 10;

    /**
     * @dev Returns the version of the contract
     * @return The version of the contract
     */
    function version() external pure override returns (string memory) {
        return VERSION;
    }

    /**
     * @dev Initialize the contract
     * @param _groth16VerifierContractAddr Address of the verifier contract
     * @param owner Owner of the contract
     */
    function initialize(address _groth16VerifierContractAddr, address owner) public initializer {
        _setGroth16Verifier(CIRCUIT_ID, IGroth16Verifier(_groth16VerifierContractAddr));

        _setInputToIndex("linkID", 0);
        _setInputToIndex("merklized", 1);
        for (uint256 i = 0; i < QUERIES_COUNT; i++) {
            _setInputToIndex(
                string(abi.encodePacked("operatorOutput_", Strings.toString(i))),
                2 + i
            );
            _setInputToIndex(
                string(abi.encodePacked("circuitQueryHash_", Strings.toString(i))),
                12 + i
            );
        }

        __Ownable_init(owner);
    }

    /**
     * @dev Verify the proof with the supported method informed in the request query data
     * packed as bytes and that the proof was generated by the sender.
     * @param sender Sender of the proof.
     * @param proof Proof packed as bytes to verify.
     * @param requestParams Request query data of the credential to verify.
     * @param responseMetadata Metadata from the response.
     * @return Array of response fields as result.
     */
    function verify(
        // solhint-disable-next-line no-unused-vars
        address sender,
        bytes calldata proof,
        bytes calldata requestParams,
        // solhint-disable-next-line no-unused-vars
        bytes calldata responseMetadata
    ) external view returns (IRequestValidator.ResponseField[] memory) {
        Query memory query = abi.decode(requestParams, (Query));
        (
            uint256[] memory inputs,
            uint256[2] memory a,
            uint256[2][2] memory b,
            uint256[2] memory c
        ) = abi.decode(proof, (uint256[], uint256[2], uint256[2][2], uint256[2]));
        PubSignals memory pubSignals = _parsePubSignals(inputs);

        _checkQueryHash(query, pubSignals);
        _checkGroupId(query.groupID);

        if (keccak256(bytes(query.circuitIds[0])) != keccak256(bytes(CIRCUIT_ID))) {
            revert WrongCircuitID(query.circuitIds[0]);
        }
        if (!getVerifierByCircuitId(CIRCUIT_ID).verify(a, b, c, inputs)) {
            revert InvalidGroth16Proof();
        }

        return _getResponseFields(pubSignals, query);
    }

    /**
     * @dev Get the request param from params of the request query data.
     * @param params Request query data of the credential to verify.
     * @param paramName Request query param name to retrieve of the credential to verify.
     * @return RequestParam for the param name of the request query data.
     */
    function getRequestParam(
        bytes calldata params,
        string memory paramName
    ) external pure returns (RequestParam memory) {
        Query memory query = abi.decode(params, (Query));

        if (keccak256(bytes(paramName)) == GROUPID_NAME) {
            return IRequestValidator.RequestParam({name: paramName, value: query.groupID});
        } else if (keccak256(bytes(paramName)) == VERIFIERID_NAME) {
            return IRequestValidator.RequestParam({name: paramName, value: query.verifierID});
        } else if (keccak256(bytes(paramName)) == NULLIFIERSESSIONID_NAME) {
            return IRequestValidator.RequestParam({name: paramName, value: 0});
        }
        revert RequestParamNameNotFound();
    }

    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
        return
            interfaceId == type(IRequestValidator).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    function _checkGroupId(uint256 groupID) internal pure {
        if (groupID == 0) {
            revert InvalidGroupID(groupID);
        }
    }

    function _checkQueryHash(Query memory query, PubSignals memory pubSignals) internal pure {
        if (query.queryHash.length > QUERIES_COUNT) {
            revert TooManyQueries(query.queryHash.length);
        }
        for (uint256 i = 0; i < query.queryHash.length; i++) {
            if (query.queryHash[i] != pubSignals.circuitQueryHash[i]) {
                revert InvalidQueryHash(query.queryHash[i], pubSignals.circuitQueryHash[i]);
            }
        }
    }

    function _parsePubSignals(uint256[] memory inputs) internal pure returns (PubSignals memory) {
        uint256[QUERIES_COUNT] memory opsOutput;
        uint256[QUERIES_COUNT] memory queryHashes;
        PubSignals memory pubSignals = PubSignals({
            linkID: 0,
            merklized: 0,
            operatorOutput: opsOutput,
            circuitQueryHash: queryHashes
        });

        pubSignals.linkID = inputs[0];
        pubSignals.merklized = inputs[1];
        for (uint256 i = 0; i < QUERIES_COUNT; i++) {
            pubSignals.operatorOutput[i] = inputs[2 + i];
            pubSignals.circuitQueryHash[i] = inputs[2 + QUERIES_COUNT + i];
        }
        return pubSignals;
    }

    function _getResponseFields(
        PubSignals memory pubSignals,
        Query memory query
    ) internal pure returns (ResponseField[] memory) {
        uint256 operatorCount = 0;
        for (uint256 i = 0; i < query.operator.length; i++) {
            if (query.operator[i] == 16) {
                operatorCount++;
            }
        }

        uint256 n = 1;
        ResponseField[] memory rfs = new ResponseField[](n + operatorCount);
        rfs[0] = ResponseField("linkID", pubSignals.linkID, "");

        uint256 m = 1;
        for (uint256 i = 0; i < query.operator.length; i++) {
            // TODO consider if can be more gas efficient. Check via gasleft() first
            if (query.operator[i] == 16) {
                rfs[m++] = ResponseField(
                    string(abi.encodePacked("operatorOutput_", Strings.toString(i))),
                    pubSignals.operatorOutput[i],
                    ""
                );
            }
        }

        return rfs;
    }
}
